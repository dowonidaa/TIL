# 20240812 [TIL] 대규모 스트림 처리
<br>

---
<br>
<br>
<br>

```
 - 대규모 스트림처리에 대해 공부해보았다.
```


---
## 읽기 요청 최적화
- 캐시 사용 
  - 모든 사용자가 같은 데이트를 요청 하는 경우, 레디스 같은 캐시를 이용하면 요청에 대한 응답속도를 빠르게 할수 있다.
  - DB의 부하를 줄일수 있다
  - 데이터에서 필터된 데이터를 가져오는 것보다 레디스에서 필터된 데이터를 가져오거나 애플리케이션 로직에서 필터링을 수행하는것이 성능상의 이점이 더 크다
  - 엣지 단에서 캐싱을 처리하면 시스템의 요청 처리량이 줄어들어 적은 수의 애플리케이션으로도 요청을 처리할 수 있습니다. 엣지 캐싱은 사용자와 가까운 곳에서 데이터를 제공하므로 네트워크 지연을 최소화하고, 사용자 경험을 향상시킬 수 있습니다.
  - 캐싱 전략을 설계할 때는 캐시 갱신 정책도 중요합니다. 예를 들어, 공지사항이 자주 변경되지 않는 경우에는 캐시의 유효 기간을 길게 설정할 수 있습니다. 반면, 변경이 잦은 경우에는 짧은 유효 기간을 설정하거나, 변경 시점에 캐시를 무효화하여 최신 데이터를 제공할 수 있도록 해야 합니다. 이러한 캐싱 전략을 통해 시스템의 효율성을 극대화할 수 있습니다.
  - 데이터 소실의 위험을 줄이기 위해 데이터의 유효성을 지속적으로 검증하고, 데이터가 손실되지 않았는지 확인해야 합니다. 또한, 캐시 계층에서 데이터 소실 시 재요청을 통해 데이터베이스에서 데이터를 다시 가져올 수 있도록 해야 합니다.


- 데이터 베이스 사용 최적화
  - **데이터베이스 인덱싱** : 조회 성능을 크게 향상시킬 수 있는 방법이다. 데이터를 빠르게 검색할 수 있다. 올바르게 설계된 인덱스는 읽기 성능을 최적화하고 쿼리 응답 시간을 줄인다. 주의할 점은 인덱스가 너무 많으면 쓰기 성능이 저하될 수 있다.
  - **데이터베이스 샤딩** : 데이터베이스를 여러 샤드로 분할하여 각각의 샤드가 독립적으로 쿼리를 처리하도록 하는 방법. 이를 통해 단일 데이터베이스에 대한 부하를 분산시킬 수 있으며, 읽기 요청에 대한 응답 속도를 향상시킬 수 있다.
    - 예  테이블 파티셔닝. 이는 기본적인 형태의 샤딩으로, 데이터베이스 수준에서 데이터를 분할.

        ```yaml
        CREATE TABLE orders (
          order_id SERIAL PRIMARY KEY,
          customer_id INT,
          order_date DATE,
          amount DECIMAL
        ) PARTITION BY RANGE (order_date);
        
        CREATE TABLE orders_2023_01 PARTITION OF orders FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');
        CREATE TABLE orders_2023_02 PARTITION OF orders FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');
        
        ```

  - **읽기 전용 데이터베이스** : 주로 읽기 요청을 처리하는 데이터베이스 인스턴스. 데이터를 주기적으로 동기화하여 최신 상태를 유지하면서 읽기 요청을 처리. 이 방법은 주 데이터베이스에 대한 읽기 부하를 줄이고 성능을 최적화.
  - **쿼리 최적화** : SQL 쿼리를 효율적으로 작성하여 데이터베이스의 읽기 성능을 향상시키는 방법. 예 불필요한 조인을 줄이고, 필요한 컬럼만 선택하며, 적절한 조건을 사용하는 것이 중요. 쿼리 실행 계획을 분석하여 병목 지점을 찾아내고, 이를 최적화할 수 있다.
  
## 쓰기 요청 최적화

- 쓰기에서 가장 많은 시간을 소요하는 부분은 DB에 데이터를 생성하는 부분.
- 비동기 처리
  - 쓰기 요청을 비동기 방식으로 처리하면 DB에 직접 접근하지 않고도 빠르게 응답을 반환할 수 있다
  - 예를 들어 메시지를 바로 DB에 쓰지 않고, 큐에 넣어 나중에 처리하는 방법
  - 이를 통해 애플리케이션은 요청을 빠르게 처리할 수 있다
  - 비동기 처리는 특히 높은 트래픽을 처리할 때 유용
  - 사용자는 요청을 보낸 후 즉시 응답을 받기 때문에, 사용자 경험이 향상된다
  - 비동기 처리 시 데이터 소실이나 오류를 방지하기 위해 큐에 데이터를 넣을 때 적절한 검증을 수행하고, 큐에 쌓인 데이터를 지속적으로 모니터링하여 실패한 요청을 재시도할 수 있는 메커니즘을 마련해야 한다
  - 데이터의 순서를 보장하고, 중복 처리를 방지하기 위한 고유 식별자(ID)를 사용해야 한다

- 배치 처리
  - 실시간으로 처리할 필요가 없는 쓰기 요청은 배치 처리를 통해 한꺼번에 처리할 수 있다
  - 예)  일정 시간마다 큐에 쌓인 메시지를 DB에 쓰는 방법이 있따.
  - 예) 매일 자정에 하루 동안 수집된 로그 데이터를 한 번에 DB에 저장하는 방식.
  - 이를 통해 실시간 처리의 부담을 줄이고, 시스템 자원을 효율적으로 사용할 수 있다.
  - 배치 처리 시에도 데이터 소실을 방지하기 위해 배치 작업 중 오류가 발생한 경우 이를 기록하고, 재시도할 수 있는 메커니즘을 마련해야 한다.
  - 배치 작업의 상태를 모니터링하고, 배치 작업이 완료되었는지 확인하는 프로세스를 마련해야 한다.

- 분산 DB
  - 단일 DB로 모든 쓰기 요청을 처리하기 어렵다면, 분산 DB를 사용하여 부하를 분산시킬 수 있습니다
  - 예) 여러 개의 DB 인스턴스를 사용하여 각 인스턴스가 특정 사용자 그룹의 데이터를 처리하도록 할 수 있다
  - 분산 DB는 데이터를 여러 개의 노드에 분산 저장하여 고가용성과 확장성을 제공
  - 샤딩(Sharding) 기법을 통해 데이터베이스를 수평으로 분할하여 각 샤드가 독립적으로 쓰기 작업을 처리하도록 할 수 있다. 이를 통해 단일 노드의 부하를 줄이고, 시스템의 전체 성능을 향상시킬 수 있다


    📌 분산 DB 사용 시 데이터 일관성을 유지하기 위해 트랜잭션 관리와 데이터 동기화에 신경 써야 함. 예) 분산 트랜잭션이나 이벤트 소싱을 사용하여 데이터 일관성을 유지할 수 있다.



## 데이터 일관성 유지

### 분산 트랜잭션

- 분산 트랜잭션은 여러 개의 독립된 시스템이나 데이터베이스에서 동시에 일어나는 트랜잭션을 일관되게 관리하는 방법.
- 단일 트랜잭션이 여러 시스템에 걸쳐 발생할 때, 모든 시스템이 해당 트랜잭션을 성공적으로 완료하거나, 모든 시스템이 트랜잭션을 실패로 처리하도록 보장한다. 이를 통해 데이터의 일관성을 유지
- 분산 트랜잭션이 필요한 이유는 마이크로서비스 아키텍처에서 여러 서비스가 독립적으로 운영되기 때문
- 주요개념
  - **트랜잭션(Transaction)**:
    - 데이터베이스의 상태를 변환하는 작업의 단위로, ACID(원자성, 일관성, 고립성, 지속성) 속성을 보장.
      - **원자성 (Atomicity)**: 트랜잭션은 전부 성공하거나 전부 실패하여, 부분적인 작업 수행이 없는 것을 보장.
      - **일관성 (Consistency)**: 트랜잭션이 완료된 후에도 데이터베이스는 모든 무결성 제약 조건을 유지.
      - **격리성 (Isolation)**: 동시에 실행되는 트랜잭션이 서로 간섭하지 않도록 보장.
      - **지속성 (Durability)**: 트랜잭션이 성공적으로 완료된 후의 결과는 시스템 장애가 발생해도 영구적으로 유지.
  - **분산 트랜잭션(Distributed Transaction)**:
    - 여러 분산된 데이터 소스에 걸쳐 트랜잭션을 수행하는 작업. 예) 여러 마이크로서비스나 데이터베이스에서 데이터를 동시에 업데이트하는 경우가 이에 해당.
  - **2PC (Two-Phase Commit)**:
    - 분산 트랜잭션을 관리하는 프로토콜로, 준비(Prepare) 단계와 커밋(Commit) 단계로 나누어 트랜잭션을 처리.
      - **준비 단계(Prepare Phase)**: 각 참여 노드는 트랜잭션 준비 상태를 확인하고, 준비 완료를 마스터 노드에 알림.
      - **커밋 단계(Commit Phase)**: 마스터 노드는 모든 참여 노드가 준비되었음을 확인하고, 트랜잭션을 커밋하도록 지시. 만약 준비가 완료되지 않은 노드가 있다면 트랜잭션을 롤백
  - **사가 패턴(Saga Pattern)**:
    - 트랜잭션을 여러 단계로 나누어 처리하고, 각 단계가 독립적으로 커밋. 실패 시 보상 트랜잭션을 실행하여 상태를 롤백.
      - **주문 생성 단계**: 사용자가 주문을 생성.
      - **결제 처리 단계**: 결제 서비스가 주문 결제를 처리.
      - **재고 감소 단계**: 재고 서비스가 주문된 상품의 재고를 감소시킴.
      - 각 단계가 성공적으로 완료되면 다음 단계로 넘어가고, 실패하면 이전 단계에서 수행된 작업을 취소.
  - **이벤트 소싱(Event Sourcing)**:
    - 상태 변화를 이벤트로 기록하고, 해당 이벤트를 재생하여 현재 상태를 유지. 이를 통해 분산 트랜잭션의 일관성을 유지할 수 있다.

- 분산 트랜잭션의 장점
  - **데이터 일관성 보장**:
    - 분산된 여러 데이터 소스에 걸쳐 일관된 데이터 상태를 유지할 수 있다. 모든 트랜잭션이 성공적으로 완료되거나 모두 실패하도록 보장.
  - **확장성**:
    - 분산 트랜잭션을 통해 여러 시스템이 독립적으로 동작하면서도, 필요한 경우 협력하여 일관된 상태를 유지할 수 있다. 이를 통해 시스템의 확장성을 높일 수 있다.
  - **신뢰성**:
    - 트랜잭션의 ACID 속성을 분산 환경에서도 유지할 수 있어 시스템의 신뢰성을 높임. 데이터 무결성과 일관성을 유지할 수 있다.
  - **복구 가능성**:
    - 트랜잭션 실패 시 롤백 메커니즘을 통해 상태를 복구할 수 있어, 시스템 안정성을 높일 수 있다.

- 분산 트랜잭션의 단점
  - **복잡성 증가**:
    - 분산 트랜잭션을 구현하고 관리하는 것은 복잡. 특히, 여러 시스템 간의 트랜잭션 동기화와 데이터 일관성을 유지하는 것은 어려운 작업임.
  - **성능 저하**:
    - 2PC와 같은 프로토콜을 사용할 경우, 트랜잭션의 준비와 커밋 단계에서 지연이 발생할 수 있다. 이는 시스템의 성능을 저하시킬 수 있음.
  - **네트워크 오버헤드**:
    - 여러 시스템 간의 통신이 필요하므로 네트워크 오버헤드가 증가할 수 있음. 이는 트랜잭션 처리 속도를 저하시킬 수 있음.
  - **복구의 어려움**:
    - 분산 트랜잭션 실패 시, 모든 시스템에서 일관된 상태로 롤백하는 것이 어려울 수 있음. 특히, 부분적으로 실패한 트랜잭션을 처리하는 데 어려움이 있을 수 있음.

- 분산 트랜잭션의 예시
  - **주문 생성과 결제 처리**:
    - 한 사용자가 온라인 쇼핑몰에서 주문을 생성하고, 결제를 진행. 주문 서비스와 결제 서비스가 각각 독립된 데이터베이스를 사용한다고 가정.
    - 분산 트랜잭션을 통해 두 서비스가 일관되게 주문과 결제를 처리해야함. 트랜잭션이 성공적으로 완료되면 두 데이터베이스에 주문 및 결제 정보가 일관되게 저장.
  - **2PC를 사용한 트랜잭션 처리**:
    - **준비 단계**: 주문 서비스와 결제 서비스가 트랜잭션을 준비. 두 서비스가 모두 준비 완료 상태를 마스터 노드에 알림.
    - **커밋 단계**: 마스터 노드는 두 서비스가 모두 준비되었음을 확인하고, 트랜잭션을 커밋하도록 지시함. 만약 하나의 서비스라도 준비되지 않았으면, 트랜잭션을 롤백.