# 20240813 [TIL] 대규모 스트림 처리
<br>

---
<br>
<br>
<br>

```
 - 대규모 스트림처리에 대해 공부해보았다.
```


---

## asdasd

## 이벤트 소싱

- 데이터 상태 변화를 이벤트로 기록하고, 해당 이벤트들을 순차적으로 재생하여 현재 상태를 파악하는 방법
- 전통적인 데이터 저장 방식과 달리, 이벤트 소싱에서는 데이터 변경 자체가 아닌 변경 이벤트를 저장
- 이러한 방식은 특히 복잡한 비즈니스 로직을 다루는 시스템에서 데이터 일관성과 추적 가능성을 높이는 데 유용
- 하지만 복잡성이 증가할 수 있으므로, 시스템의 요구사항에 따라 신중하게 적용해야 함

- 주요개념
    - **이벤트(Event)**:
        - 데이터의 상태 변화를 나타내는 기록. 예를 들어, "주문 생성", "결제 완료", "주문 취소" 등이 이벤트
    - **이벤트 스토어(Event Store)**:
        - 이벤트를 저장하는 저장소. 전통적인 데이터베이스 대신 이벤트를 순서대로 저장하는 스토리지. 이는 이벤트의 불변성과 순차성을 보장.
    - **애그리게이트(Aggregate)**:
        - 관련된 이벤트를 모아 현재 상태를 재현할 수 있는 엔터티. 애그리게이트는 도메인 모델의 일부분으로, 이벤트를 적용하여 상태를 변화시킴.
    - **커맨드(Command)**:
        - 애그리게이트에 특정 동작을 지시하는 명령. 커맨드는 이벤트를 생성하는 트리거 역할
    - **프로젝션(Projection)**:
        - 이벤트를 읽기 모델로 변환하여 조회 성능을 최적화하는 방식. 이벤트를 기반으로 읽기 전용 데이터베이스를 업데이트.
- 이벤트 소싱의 장점
    - **데이터 변경 이력 추적**:
        - 모든 상태 변화를 이벤트로 기록하므로, 데이터 변경 이력을 완벽하게 추적할 수 있다. 이는 감사와 디버깅에 유용.
    - **복구 및 재생**:
        - 이벤트를 재생하여 시스템의 현재 상태를 복구할 수 있다. 이는 데이터 손실이나 시스템 장애 시 유용
    - **CQRS와의 자연스러운 통합**:
        - 이벤트 소싱은 CQRS(Command Query Responsibility Segregation)와 잘 어울림. 명령과 조회를 분리하여 성능과 확장성을 최적화할 수 있따
- 이벤트 소싱의 단점
    - **복잡성 증가**:
        - 시스템 설계와 구현의 복잡성이 증가. 이벤트 모델링과 이벤트 스토어 관리가 필요
    - **읽기 성능**:
        - 이벤트를 재생하여 현재 상태를 계산해야 하므로, 읽기 성능이 저하될 수 있다. 이를 해결하기 위해 프로젝션과 CQRS를 활용할 수 있다

  ### 


### CQRS

- CQRS는 **명령(Query)과 조회(Query)의 책임을 분리**하는 소프트웨어 디자인 패턴
- 읽기 작업과 쓰기 작업을 서로 다른 모델로 분리하여, 각 작업에 최적화된 구조를 사용할 수 있도록 함
- 시스템의 성능, 확장성, 유지보수성을 향상시키는 데 도움이 됨.

- 주요 개념
    - **명령(Command)**:
        - 데이터를 변경하는 작업. 예를 들어, 주문 생성, 결제 처리, 계정 업데이트 등이 명령에 해당. 명령은 데이터베이스에 대한 쓰기 작업을 수행.
        - **명령 모델**은 데이터의 상태 변경을 담당. 복잡한 비즈니스 로직을 포함할 수 있으며, 데이터 무결성을 보장하기 위해 트랜잭션을 사용.
    - **조회(Query)**:
        - 데이터를 조회하는 작업. 예를 들어, 주문 내역 조회, 계정 정보 조회 등이 조회에 해당. 조회는 데이터베이스에 대한 읽기 작업을 수행.
        - **조회 모델**은 읽기 전용 데이터베이스 또는 캐시를 사용하여 빠른 응답을 제공. 이는 단순한 데이터 조회를 위한 최적화된 구조를 가질 수 있다.
- CQRS의 장점
    - **성능 향상**:
        - 읽기와 쓰기를 분리하여 각 작업에 최적화된 데이터 저장소와 인프라를 사용할 수 있다. 예를 들어, 조회 성능을 높이기 위해 읽기 전용 데이터베이스를 사용하거나, 캐시를 활용할 수 있다
    - **확장성**:
        - 읽기와 쓰기를 독립적으로 확장할 수 있다. 예를 들어, 읽기 요청이 많은 경우 조회 모델을 수평으로 확장하여 부하를 분산시킬 수 있다.
    - **유지보수성**:
        - 비즈니스 로직이 명령 모델에 집중되므로, 복잡한 상태 변경 로직을 관리하기 쉽다. 읽기 모델은 단순화되어 유지보수하기 용이.
    - **데이터 일관성**:
        - CQRS는 이벤트 소싱과 잘 어울림. 이벤트 소싱을 통해 데이터 상태 변경을 이벤트로 기록하고, 이벤트를 재생하여 현재 상태를 유지할 수 있다. 이를 통해 데이터 일관성을 보장할 수 있다

- CQRS의 단점
    - **복잡성 증가**:
        - 시스템 설계와 구현의 복잡성이 증가. 명령 모델과 조회 모델을 각각 설계하고 관리해야 함.
    - **데이터 동기화**:
        - 명령 모델과 조회 모델 간의 데이터 동기화가 필요. 이는 추가적인 구현과 관리가 필요.

## 모니터링과 로깅

- 대규모 시스템에서 모니터링과 로깅은 시스템의 안정성과 성능을 유지하는 데 필수적인 역할.
- 이를 통해 시스템의 상태를 실시간으로 파악하고, 문제 발생 시 신속하게 대응할 수 있다.
- 모니터링과 로깅 모두 다음의 항목을 주요 사항으로 봄.
    - **시스템 안정성 유지**
    - **성능 최적화**
    - **문제 예방 및 대응**

### 모니터링

- 애플리케이션, DB, 캐시 등 각 컴포넌트의 성능을 모니터링
- 이를 위해 Prometheus, Grafana 같은 도구를 사용할 수 있다
- 시스템의 주요 지표(TPS, 응답 시간, 에러율 등)를 모니터링하고, 이상 징후를 감지하면 알림을 받을 수 있다
- 모니터링을 통해 시스템의 상태를 실시간으로 파악하고, 문제 발생 시 빠르게 대응할 수 있다. 또한, 모니터링 데이터를 기반으로 시스템의 성능을 분석하고, 최적화할 수 있다.

- 주요사항
    - **실시간 상태 파악:**
        - 모니터링 도구는 시스템의 주요 지표(TPS, 응답 시간, 에러율 등)를 실시간으로 확인할 수 있게 한다. 이를 통해 시스템의 현재 상태를 파악하고, 이상 징후를 빠르게 감지할 수 있다
    - **자동 알림:**
        - 특정 임계치를 초과하는 경우 자동으로 알림을 받을 수 있어, 잠재적인 문제를 조기에 발견하고 대응할 수 있다.
    - **성능 분석**:
        - 모니터링 데이터를 기반으로 시스템의 성능을 분석할 수 있다. 예를 들어, 특정 시간대에 트래픽이 급증하는 경우 해당 시간대에 자원을 추가로 할당하여 성능을 최적화할 수 있다.
    - **병목 지점 파악:**
        - 모니터링을 통해 시스템의 병목 지점을 파악하고, 이를 최적화하여 전체 성능을 향상시킬 수 있다.
    - **사전 예방**:
        - 실시간 모니터링을 통해 문제가 발생하기 전에 예방 조치를 취할 수 있다. 예를 들어, 디스크 사용량이 급증하는 경우 디스크 용량을 미리 확장할 수 있다
    - **신속한 대응**:
        - 문제가 발생했을 때 빠르게 감지하고 대응할 수 있어, 시스템 다운타임을 최소화할 수 있다

###  로깅

- 애플리케이션의 주요 이벤트를 로깅하여 문제 발생 시 원인을 추적할 수 있다
- 로그는 Elasticsearch, Logstash, Kibana(ELK 스택) 등을 사용하여 수집, 저장, 분석할 수 있다
- 이를 통해 시스템의 상태를 파악하고, 문제를 해결할 수 있다
- 로깅은 시스템의 모든 중요한 이벤트를 기록하므로, 문제 발생 시 정확한 원인을 파악하는 데 큰 도움이 됨

- 주요사항
    - **이벤트 추적:**
        - 로깅을 통해 시스템에서 발생하는 모든 중요한 이벤트를 기록. 이는 문제가 발생했을 때 원인을 추적하고 분석하는 데 도움이 됨
    - **디버깅 및 오류 해결:**
        - 로그를 분석하여 오류의 원인을 파악하고, 이를 기반으로 문제를 해결할 수 있다. 이는 특히 복잡한 대규모 시스템에서 문제 해결 시간을 단축시킴
    - **패턴 분석:**
        - 로그 데이터를 분석하여 사용자의 행동 패턴이나 시스템의 성능 패턴을 이해할 수 있다 이를 통해 시스템을 더 효율적으로 운영할 수 있다
    - **장기적 최적화**:
        - 로그 데이터를 장기적으로 분석하여 시스템의 성능 저하 원인을 찾아내고, 지속적인 최적화를 진행할 수 있다.
    - **원인 분석**:
        - 문제가 발생한 후 로그를 분석하여 정확한 원인을 파악할 수 있다. 이는 같은 문제가 다시 발생하지 않도록 예방하는 데 도움이 됨
    - **법적 및 규제 요구 사항 준수**:
        - 많은 산업에서는 로그 데이터를 보관하고 분석하는 것이 법적 및 규제 요구 사항을 준수하는 데 필수적임. 이는 감사 및 규제 대응에 중요한 역할을 함

## 테스트와 배포

- 대규모 시스템에서는 테스트와 배포도 중요한 요소
- 시스템이 정상적으로 동작하는지 확인하고, 문제 발생 시 빠르게 대응할 수 있어야 함.

### 테스트

- **단위 테스트(Unit Test):**
    - 시스템의 개별 구성 요소를 테스트하여 각 부분이 예상대로 동작하는지 확인.
    - JUnit, TestNG와 같은 도구를 사용하여 자동화된 단위 테스트를 작성하고 실행.
    - 단위 테스트는 개발 초기 단계에서 발생할 수 있는 결함을 조기에 발견하고 수정하는 데 유용.
- **통합 테스트(Integration Test)**
    - 여러 구성 요소가 함께 동작하는지를 테스트. 이는 개별 구성 요소들이 올바르게 상호작용하는지를 검증
    - Spring Boot에서는 @SpringBootTest 어노테이션을 사용하여 통합 테스트를 작성할 수 있다.
    - 통합 테스트는 시스템의 다양한 부분들이 함께 올바르게 동작하는지를 확인하여, 인터페이스 간의 문제를 발견하는 데 유용
- **부하 테스트(Load Test)**:
    - 시스템이 높은 트래픽 상황에서도 안정적으로 동작하는지를 테스트
    - Apache JMeter와 같은 도구를 사용하여 다양한 부하 시나리오를 설정하고 테스트를 수행.
    - 부하 테스트를 통해 시스템의 성능 한계를 파악하고, 병목 지점을 찾아 최적화할 수 있다.
- **회귀 테스트(Regression Test)**:
    - 새로운 코드 변경이 기존 기능에 영향을 미치지 않는지 확인
    - 기존 테스트 케이스를 자동화하여 주기적으로 실행함으로써, 코드 변경으로 인한 결함을 방지할 수 있다
    - 회귀 테스트는 지속적인 코드 변경에도 시스템의 안정성을 유지하는 데 중요.
- **사용자 수용 테스트(UAT, User Acceptance Test)**:
    - 실제 사용자 환경에서 시스템을 테스트하여, 사용자가 요구하는 기능이 모두 제대로 동작하는지 확인.
    - 사용자 피드백을 반영하여 시스템을 최종 조정하고, 배포 준비를 완료.
    - 사용자 수용 테스트는 시스템이 실제 운영 환경에서 기대대로 동작하는지 확인하는 중요한 단계.

### 1.5.2

- **지속적인 통합(CI, Continuous Integration)**:
    - 개발자가 변경한 코드를 자주, 자동으로 빌드하고 테스트하여, 코드 변경 시점에서 발생할 수 있는 문제를 조기에 발견하고 해결.
    - Jenkins, GitLab CI, Travis CI와 같은 도구를 사용하여 CI 파이프라인을 설정.
    - CI는 코드 통합을 빠르고 효율적으로 수행하여 개발 주기를 단축시키고, 코드 품질을 높임.
- **지속적인 배포(CD, Continuous Deployment)**:
    - CI 파이프라인을 통해 검증된 코드를 자동으로 프로덕션 환경에 배포.
    - Argo CD와 같은 도구를 사용하여 CD 파이프라인을 설정.
    - CD는 코드 변경 사항을 빠르고 안전하게 프로덕션 환경에 적용하여, 새로운 기능을 신속하게 제공할 수 있다.
- **Canary 배포**:
    - 새로운 버전을 전체 시스템에 배포하기 전에, 일부 사용자에게만 배포하여 문제가 없는지 확인.
    - 문제가 발생할 경우 빠르게 이전 버전으로 롤백할 수 있다.
    - Canary 배포는 리스크를 최소화하면서 새로운 기능을 단계적으로 도입할 수 있는 방법.
- **블루-그린 배포(Blue-Green Deployment)**:
    - 두 개의 환경(블루와 그린)을 사용하여 하나는 현재 운영 중인 환경이고, 다른 하나는 새로운 버전을 배포하는 환경으로 사용.
    - 새로운 버전을 그린 환경에 배포한 후, 모든 트래픽을 그린 환경으로 전환. 문제가 발생하면 블루 환경으로 빠르게 롤백할 수 있다.
    - 블루-그린 배포는 무중단 배포를 가능하게 하며, 배포 실패 시 신속한 복구를 제공.
- **롤링 배포(Rolling Deployment)**:
    - 새로운 버전을 점진적으로 배포하여, 각 서버를 순차적으로 업데이트.
    - 시스템 가동 시간을 유지하면서 점진적으로 새로운 버전을 도입할 수 있다.
    - 롤링 배포는 대규모 시스템에서 무중단 배포를 구현하는 데 유용.

---

---

#  RabbitMQ

## RabbitMQ란

- **RabbitMQ**는 메시지 브로커. 메시지 브로커는 데이터(메시지)를 송신자(프로듀서)로부터 수신자(컨슈머)에게 전달하는 중간 매개체 역할.
- RabbitMQ는 이러한 메시지를 큐(queue)에 저장하고, 필요할 때 적절한 수신자에게 전달.

### **RabbitMQ의 역할**

- **비동기 처리**: 데이터를 비동기적으로 처리하여 시스템의 응답성을 높임.
- **부하 분산**: 여러 소비자에게 메시지를 분산시켜 시스템의 부하를 균형 있게 분산.
- **내결함성**: 메시지를 안전하게 저장하여 시스템 장애 시 데이터 손실을 방지.

### 2.1.2 장단점

- 장점
    - **신뢰성(Reliability)**
        - **메시지 지속성**: RabbitMQ는 메시지를 디스크에 저장하여 시스템 장애 발생 시에도 메시지가 손실되지 않도록 한다.
        - **확인 메커니즘**: 메시지가 성공적으로 소비자에게 전달되었는지 확인하는 ACK(acknowledgment) 메커니즘을 지원.
    - **유연성(Flexibility)**
        - **다양한 메시지 패턴**: RabbitMQ는 여러 가지 메시지 전달 패턴(단일 소비자, 다중 소비자, 라운드 로빈, 팬아웃, 주제 기반 등)을 지원.
        - **프로토콜 지원**: 기본적으로 AMQP(Advanced Message Queuing Protocol)를 사용하지만, STOMP, MQTT 등 다양한 프로토콜도 지원.
    - **확장성(Scalability)**
        - **클러스터링**: RabbitMQ는 클러스터링을 통해 여러 노드로 구성된 환경에서 높은 가용성과 부하 분산을 제공.
        - **분산 아키텍처**: 페더레이션(federation) 및 셰어드 노딩(sharded nodes)을 통해 분산된 메시징 시스템을 구축할 수 있다.
    - **관리 및 모니터링(Manageability and Monitoring)**
        - **관리 인터페이스**: 웹 기반 관리 인터페이스를 통해 큐, 익스체인지, 바인딩 등을 쉽게 관리할 수 있다.
        - **플러그인 시스템**: 다양한 플러그인을 통해 기능을 확장할 수 있다(예: 관리 플러그인, 모니터링 플러그인 등).
    - **성능(Performance)**
        - **높은 처리량**: 적절히 구성된 RabbitMQ는 높은 메시지 처리량을 제공하여 대규모 애플리케이션에서도 효과적으로 사용할 수 있다.
- 단점
    - **설정 및 운영 복잡성(Setup and Operational Complexity)**
        - **복잡한 설정**: RabbitMQ의 초기 설정이 다소 복잡할 수 있으며, 클러스터링 및 분산 환경에서는 더욱 많은 설정이 필요
        - **운영 관리**: 대규모 환경에서 RabbitMQ를 운영하고 관리하는 데 있어서 추가적인 노력이 필요
    - **성능 문제(Performance Issues)**
        - **메시지 브로커 오버헤드**: RabbitMQ는 모든 메시지를 중앙 브로커를 통해 전달하기 때문에, 높은 트래픽 상황에서는 브로커의 오버헤드가 발생할 수 있다.
        - **대규모 메시지 처리**: 매우 대규모의 메시지를 처리할 때 성능 저하가 발생할 수 있으며, 이러한 경우에는 적절한 클러스터링 및 최적화가 필요
    - **운영 비용(Operational Costs)**
        - **리소스 소비**: RabbitMQ는 메모리와 CPU 자원을 많이 소비할 수 있어, 충분한 리소스를 제공해야 원활하게 운영될 수 있다.
        - **모니터링 및 유지보수**: 지속적인 모니터링과 유지보수가 필요하며, 이를 위해 추가적인 인력과 비용이 발생할 수 있다.
    - **제한된 메시지 크기(Limited Message Size)**
        - **메시지 크기 제한**: RabbitMQ는 매우 큰 메시지 처리에 제한이 있을 수 있으며, 대용량 파일 전송에는 적합하지 않을 수 있다.
    - **러닝 커브(Learning Curve)**
        - **학습 필요성**: RabbitMQ의 개념과 설정을 이해하는 데 시간이 걸릴 수 있다.


## **RabbitMQ의 기본 구성 요소**

###  **메시지(Message)**

- 메시지는 RabbitMQ를 통해 전달되는 데이터 단위. 예를 들어, 사용자 등록 정보나 주문 내역이 메시지가 될수 잇음.

###  **프로듀서(Producer)**

- 메시지를 생성하고 RabbitMQ에 보내는 역할 예를 들어, 웹 애플리케이션이 사용자 등록 정보를 RabbitMQ에 보내는 경우 프로듀서가 됨.

### **큐(Queue)**

- 메시지를 저장하는 장소입니다. 메시지는 큐에 저장되었다가 소비자에게 전달됩니다. 큐는 FIFO(First In, First Out) 방식으로 메시지를 처리합니다.

### ** 컨슈머(Consumer)**

- 큐에서 메시지를 가져와 처리하는 역할. 예를 들어, 이메일 발송 서비스가 큐에서 사용자 등록 정보를 가져와 환영 이메일을 보내는 경우 컨슈머가 됨.

### ** 익스체인지(Exchange)**

- 메시지를 적절한 큐로 라우팅하는 역할. 프로듀서는 메시지를 직접 큐에 보내지 않고, 익스체인지에 보내며, 익스체인지는 메시지를 적절한 큐로 전달.

## **RabbitMQ와 AMQP**

- RabbitMQ는 **AMQP**(Advanced Message Queuing Protocol)를 사용.
- AMQP는 메시지 브로커를 위한 프로토콜로, 메시지의 생성, 전송, 큐잉, 라우팅 등을 표준화하여 메시지 브로커가 상호 운용될 수 있게 함.
- 여기서 프로토콜(Protocol)은 컴퓨터 네트워크에서 데이터를 주고받기 위한 일련의 규칙과 절차를 말함. 쉽게 말해, 컴퓨터나 장치들이 서로 통신할 때 어떻게 소통해야 하는지를 정해 놓은 약속이다.

### ** AMQP의 주요 개념**

- **메시지(Message)**: 전송되는 데이터 단위.
- **큐(Queue)**: 메시지를 저장하고 전달하는 구조.
- **익스체인지(Exchange)**: 메시지를 큐로 라우팅하는 역할을 함.
- **바인딩(Binding)**: 익스체인지와 큐를 연결하는 설정. 바인딩을 통해 메시지가 어느 큐로 전달될지 정의.

###  익스체인지 유형

- 메시지 브로커가 메시지를 교환기에서 큐로 라우팅하는 방식.
- 익스체인지는 다양한 방식으로 메시지를 라우팅할 수 있으며, 주로 메시지의 라우팅 키와 바인딩 키 또는 패턴을 기반으로 작동함.
1. **Direct Exchange**
    - 라우팅 키가 정확히 일치하는 큐로 메시지를 전달함.
    - 예를 들어, 라우팅 키가 error인 메시지는 error라는 바인딩 키를 가진 큐로 전달됨.
2. **Topic Exchange**
    - 라우팅 키의 패턴을 사용하여 메시지를 라우팅. 패턴에는 와일드카드 * (단어 하나)와 # (0개 이상의 단어)가 사용됨
    - 예를 들어, 라우팅 키가 quick.orange.rabbit인 메시지는 바인딩 키가 *.orange.*인 큐로 전달됨.
3. **Fanout Exchange**
    - 라우팅 키를 무시하고 교환기에 바인딩된 모든 큐로 메시지를 브로드캐스트함.
    - 모든 바인딩된 큐로 메시지가 전달됨.
4. **Headers Exchange**
    - 라우팅 키 대신 메시지의 헤더를 기반으로 메시지를 라우팅함.
    - 헤더 값과 바인딩된 헤더 값이 일치하는 큐로 메시지를 전달함.



#  Kafka

## **Kafka란**

- **Kafka**는 분산 스트리밍 플랫폼으로, 주로 실시간 데이터 피드의 빅 데이터 처리를 목적으로 사용.
- Kafka는 메시지 큐와 유사하지만, 대용량 데이터 스트림을 저장하고 실시간으로 분석하거나 처리하는 데 중점을 둠.

### **Kafka의 역할**

- **실시간 데이터 처리**: 대용량 데이터를 실시간으로 처리하고 분석.
- **데이터 통합**: 다양한 소스에서 데이터를 수집하고 이를 통합하여 분석.
- **내결함성**: 데이터 손실 없이 안정적으로 데이터를 저장하고 전송.

### ** 장단점**

- 장점
    - **신뢰성(Reliability)**
        - **데이터 복제**: 데이터를 여러 브로커에 복제하여 저장하므로, 단일 브로커 장애 시에도 데이터 손실을 방지할 수 있다.
        - **확인 메커니즘**: 데이터가 소비자에게 성공적으로 전달되었는지 확인하는 기능을 제공.
    - **유연성(Flexibility)**
        - **다양한 소비자 패턴**: 여러 소비자가 동시에 데이터를 구독할 수 있다.
        - **프로토콜 지원**: 기본적으로 Kafka의 프로토콜을 사용하지만, 다양한 클라이언트를 통해 다른 언어에서도 사용할 수 있다.
    - **확장성(Scalability)**
        - **분산 시스템**: 클러스터링을 통해 여러 노드에서 데이터를 분산 처리할 수 있다.
        - **수평 확장**: 브로커와 파티션을 추가하여 쉽게 확장할 수 있다.
    - **성능(Performance)**
        - **높은 처리량**: 대용량 데이터를 실시간으로 빠르게 처리할 수 있다.
        - **저지연**: 데이터 전송의 지연을 최소화하여 실시간 처리가 가능함.
    - **관리 및 모니터링(Manageability and Monitoring)**
        - **관리 도구**: 다양한 관리 도구를 통해 클러스터를 모니터링하고 관리할 수 있다.
        - **플러그인 시스템**: 다양한 플러그인을 통해 기능을 확장할 수 있다.
- 단점
    - **설정 및 운영 복잡성(Setup and Operational Complexity)**
        - **복잡한 설정**: 초기 설정이 다소 복잡할 수 있으며, 클러스터링 및 분산 환경에서는 더 많은 설정이 필요
        - **운영 관리**: 대규모 환경에서 운영하고 관리하는 데 추가적인 노력이 필요할 수 있다.
    - **성능 문제(Performance Issues)**
        - **브로커 오버헤드**: 높은 트래픽 상황에서는 브로커의 오버헤드가 발생할 수 있다.
        - **대규모 메시지 처리**: 매우 대규모의 메시지를 처리할 때 성능 저하가 발생할 수 있으며, 이러한 경우 적절한 클러스터링 및 최적화가 필요.
    - **운영 비용(Operational Costs)**
        - **리소스 소비**: 메모리와 CPU 자원을 많이 소비할 수 있어, 충분한 리소스를 제공해야 원활하게 운영될 수 있다.
        - **모니터링 및 유지보수**: 지속적인 모니터링과 유지보수가 필요하며, 이를 위해 추가적인 인력과 비용이 발생할 수 있다.
    - **러닝 커브(Learning Curve)**
        - **학습 필요성**: 개념과 설정을 이해하는 데 시간이 걸릴 수 있으며 다소 난이도가 있다.

## ** Kafka의 기본 구성 요소**

### ** 메시지(Message)**

- 메시지는 Kafka를 통해 전달되는 데이터 단위. 예를 들어, 로그 데이터나 이벤트 데이터가 메시지가 될 수 있다.
- 메시지는 키(key), 값(value), 타임스탬프(timestamp), 그리고 몇 가지 메타데이터로 구성됨.

### **프로듀서(Producer)**

- 메시지를 생성하고 Kafka에 보내는 역할. 예를 들어, 웹 애플리케이션이 로그 데이터를 Kafka에 보내는 경우 프로듀서가 됨.
- 프로듀서는 특정 토픽(topic)에 메시지를 보냄.

### ** 토픽(Topic)**

- 메시지를 저장하는 장소. 메시지는 토픽에 저장되었다가 소비자에게 전달됨.
- 토픽은 여러 파티션(partition)으로 나누어질 수 있으며, 파티션은 메시지를 순서대로 저장합니다. 파티션을 통해 병렬 처리가 가능함.
- 예: “user-activity”라는 토픽에 사용자의 활동 로그를 저장할 수 있다.

### **파티션(Partition)**

- 파티션은 토픽을 물리적으로 나눈 단위로, 각 파티션은 독립적으로 메시지를 저장하고 관리.
- 각 파티션은 메시지를 순서대로 저장하며, 파티션 내의 메시지는 고유한 오프셋(offset)으로 식별됨.
- 파티션을 통해 데이터를 병렬로 처리할 수 있으며, 클러스터 내의 여러 브로커에 분산시켜 저장할 수 있다.

### **키(Key)**

- 키는 메시지를 특정 파티션에 할당하는 데 사용되는 값.
- 동일한 키를 가진 메시지는 항상 동일한 파티션에 저장됨.
- 예를 들어, 특정 사용자 ID를 키로 사용하여 해당 사용자의 모든 이벤트가 동일한 파티션에 저장되도록 할 수 있다.

### **컨슈머(Consumer)**

- 토픽에서 메시지를 가져와 처리하는 역할.
- 컨슈머는 특정 컨슈머 그룹(consumer group)에 속하며, 같은 그룹에 속한 컨슈머들은 토픽의 파티션을 분산 처리.
- 기본적으로 컨슈머는 스티키 파티셔닝(Sticky Partitioning)을 사용. 이는 특정 컨슈머가 특정 파티션에 붙어서 계속해서 데이터를 처리하는 방식으로, 이는 데이터 지역성을 높여 캐시 히트율을 증가시키고 전반적인 처리 성능을 향상시킴.

### **브로커(Broker)**

- Kafka 클러스터의 각 서버를 의미하며, 메시지를 저장하고 전송하는 역할.
- 하나의 Kafka 클러스터는 여러 브로커로 구성될 수 있으며, 각 브로커는 하나 이상의 토픽 파티션을 관리.

### **주키퍼(Zookeeper)**

- Kafka 클러스터를 관리하고 조정하는 데 사용되는 분산 코디네이션 서비스.
- 주키퍼는 브로커의 메타데이터를 저장하고, 브로커 간의 상호작용을 조정.

## **Kafka와 RabbitMQ의 차이점**

### **설계 철학**

- **RabbitMQ**: 전통적인 메시지 브로커로, 메시지의 안정적 전달과 큐잉에 중점을 둠.
- **Kafka**: 분산 스트리밍 플랫폼으로, 대규모 실시간 데이터 스트림의 저장과 분석에 중점을 둠

### **메시지 모델**

- **RabbitMQ**: 큐(queue)를 중심으로 메시지를 전달함. 메시지는 큐에 저장되고, 큐에서 하나 이상의 컨슈머에게 전달됨.
- **Kafka**: 토픽(topic)을 중심으로 메시지를 저장. 메시지는 토픽의 파티션에 저장되고, 컨슈머는 이 파티션에서 메시지를 읽음.

### **메시지 지속성**

- **RabbitMQ**: 메시지를 메모리나 디스크에 저장할 수 있으며, 일반적으로 단기 저장을 목표로 함.
- **Kafka**: 메시지를 디스크에 저장하며, 장기 저장을 목표로 함. 데이터 로그는 설정된 기간 동안 보존됨.

### 사용

- **RabbitMQ**: 작업 큐, 요청/응답 패턴, 비동기 작업 처리 등 전통적인 메시지 큐 사용 사례에 적합.
- **Kafka**: 실시간 데이터 스트리밍, 로그 수집 및 분석, 이벤트 소싱 등 대규모 데이터 스트림 처리에 적합.